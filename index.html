<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#f5f5f7">
    <title>CANR â€” Canvas to Reality</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='22' fill='%23007AFF'/><text x='50' y='68' font-size='52' text-anchor='middle' fill='white' font-family='system-ui' font-weight='700'>CR</text></svg>">
    <style>
        /* ===== Apple Design System ===== */
        :root {
            --bg: #f5f5f7;
            --surface: #ffffff;
            --surface2: #f2f2f7;
            --border: rgba(0,0,0,0.08);
            --text: #1d1d1f;
            --text2: #86868b;
            --text3: #aeaeb2;
            --blue: #007AFF;
            --blue-hover: #0066d6;
            --red: #FF3B30;
            --green: #34C759;
            --orange: #FF9500;
            --fill-active: #007AFF;
            --shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
            --shadow-lg: 0 4px 16px rgba(0,0,0,0.1), 0 1px 4px rgba(0,0,0,0.06);
            --radius: 12px;
            --radius-sm: 8px;
            --glass: rgba(255,255,255,0.72);
            --glass-border: rgba(255,255,255,0.5);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100dvh; width: 100vw;
            overflow: hidden;
            user-select: none; -webkit-user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        /* ===== Loading ===== */
        #loading-screen {
            position: fixed; inset: 0; z-index: 1000;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: var(--bg);
            transition: opacity 0.5s ease;
        }
        #loading-screen.done { opacity: 0; pointer-events: none; }
        .load-icon {
            width: 64px; height: 64px; border-radius: 16px;
            background: var(--blue);
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 24px; font-weight: 700;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,122,255,0.3);
        }
        .load-title { font-size: 22px; font-weight: 600; color: var(--text); }
        .load-subtitle { font-size: 15px; color: var(--text2); margin-top: 4px; }
        .load-progress { width: min(360px, 80vw); margin-top: 32px; }
        .load-row { margin-bottom: 16px; }
        .load-row-label {
            display: flex; justify-content: space-between;
            font-size: 13px; color: var(--text2); margin-bottom: 6px;
        }
        .load-track {
            height: 4px; background: var(--surface2); border-radius: 2px; overflow: hidden;
        }
        .load-fill {
            height: 100%; width: 0%; border-radius: 2px;
            background: var(--blue);
            transition: width 0.3s ease;
        }
        .load-status {
            font-size: 13px; color: var(--text3); text-align: center; margin-top: 24px;
        }
        .load-error {
            font-size: 13px; color: var(--red); text-align: center;
            margin-top: 12px; display: none; max-width: 80vw;
        }

        /* ===== App ===== */
        #app { display: none; flex-direction: column; height: 100dvh; }
        #app.active { display: flex; }

        /* Navbar */
        .navbar {
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 16px; height: 48px;
            background: var(--glass);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border-bottom: 0.5px solid var(--border);
            flex-shrink: 0; z-index: 10;
        }
        .navbar-title {
            font-size: 17px; font-weight: 600; letter-spacing: -0.2px;
        }
        .navbar-status {
            font-size: 12px; color: var(--text2);
            font-variant-numeric: tabular-nums;
        }

        /* Canvas area */
        .canvas-area {
            flex: 1; display: flex; gap: 1px;
            background: var(--border);
            min-height: 0; overflow: hidden;
        }
        .pane {
            flex: 1; display: flex; flex-direction: column;
            background: var(--surface2);
            min-width: 0; position: relative;
        }
        .pane-header {
            display: flex; align-items: center; justify-content: center;
            height: 28px; flex-shrink: 0;
            font-size: 11px; font-weight: 500; color: var(--text3);
            text-transform: uppercase; letter-spacing: 0.8px;
        }
        .pane-body {
            flex: 1; display: flex; align-items: center; justify-content: center;
            padding: 8px; min-height: 0;
        }
        canvas {
            border-radius: var(--radius-sm);
            max-width: 100%; max-height: 100%;
            box-shadow: var(--shadow);
        }
        #sketch {
            background: #fff; cursor: crosshair; touch-action: none;
        }
        #output {
            background: var(--surface2);
        }

        /* Generating indicator */
        .gen-indicator {
            position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); color: white;
            font-size: 11px; font-weight: 500;
            padding: 4px 12px; border-radius: 100px;
            opacity: 0; transition: opacity 0.2s;
            backdrop-filter: blur(8px);
        }
        .gen-indicator.active { opacity: 1; }

        /* Bottom bar */
        .bottom-bar {
            background: var(--glass);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border-top: 0.5px solid var(--border);
            flex-shrink: 0;
        }

        /* Toolbar */
        .toolbar {
            display: flex; align-items: center; gap: 6px;
            padding: 8px 12px;
        }
        .tool-group {
            display: flex; align-items: center; gap: 2px;
        }
        .tool-sep {
            width: 1px; height: 20px; background: var(--border); margin: 0 4px;
        }
        .spacer { flex: 1; }

        /* Segmented control (Apple-style) */
        .seg-control {
            display: flex; background: var(--surface2);
            border-radius: 8px; padding: 2px; position: relative;
        }
        .seg-btn {
            padding: 5px 12px; font-size: 13px; font-weight: 500;
            border: none; background: none; color: var(--text2);
            border-radius: 6px; cursor: pointer;
            transition: all 0.2s ease; position: relative; z-index: 1;
        }
        .seg-btn.active {
            background: var(--surface);
            color: var(--text);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* Icon buttons */
        .icon-btn {
            width: 36px; height: 36px;
            display: flex; align-items: center; justify-content: center;
            border: none; background: var(--surface2);
            border-radius: var(--radius-sm); cursor: pointer;
            color: var(--text); font-size: 16px;
            transition: all 0.15s ease;
        }
        .icon-btn:hover { background: #e8e8ed; }
        .icon-btn:active { transform: scale(0.92); }
        .icon-btn.accent { background: var(--blue); color: white; }
        .icon-btn.accent:hover { background: var(--blue-hover); }
        .icon-btn svg { width: 18px; height: 18px; }

        /* Slider (Apple-style) */
        .slider-group {
            display: flex; align-items: center; gap: 6px;
        }
        .slider-label {
            font-size: 11px; color: var(--text3); font-weight: 500;
            min-width: 32px;
        }
        input[type=range] {
            -webkit-appearance: none; appearance: none;
            height: 4px; background: var(--surface2);
            border-radius: 2px; outline: none; width: 80px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px; height: 20px;
            background: var(--surface);
            border-radius: 50%; cursor: pointer;
            box-shadow: 0 0.5px 4px rgba(0,0,0,0.15), 0 0 0.5px rgba(0,0,0,0.1);
        }

        /* Prompt */
        .prompt-row {
            padding: 0 12px 10px;
        }
        #prompt {
            width: 100%;
            background: var(--surface2);
            color: var(--text);
            border: none; border-radius: 10px;
            padding: 10px 14px;
            font-size: 15px; outline: none;
            font-family: inherit;
            transition: box-shadow 0.2s;
        }
        #prompt:focus {
            box-shadow: 0 0 0 3px rgba(0,122,255,0.2);
        }
        #prompt::placeholder { color: var(--text3); }

        /* Brush preview */
        #brush-preview {
            position: fixed; pointer-events: none; z-index: 500;
            border: 1.5px solid var(--blue);
            border-radius: 50%; display: none;
            opacity: 0.6;
        }

        /* Mode pill */
        .mode-pill {
            font-size: 11px; font-weight: 600;
            padding: 3px 8px; border-radius: 100px;
            border: none; cursor: pointer;
            transition: all 0.2s;
        }
        .mode-pill.gpu { background: rgba(0,122,255,0.12); color: var(--blue); }
        .mode-pill.cpu { background: rgba(255,149,0,0.12); color: var(--orange); }

        /* Responsive */
        @media (max-width: 700px) {
            .canvas-area { flex-direction: column; }
            input[type=range] { width: 60px; }
            .slider-label { display: none; }
        }

        /* SVG icons inline */
        .ico { display: inline-flex; }
    </style>
</head>
<body>

<!-- Loading -->
<div id="loading-screen">
    <div class="load-icon">CR</div>
    <div class="load-title">Canvas to Reality</div>
    <div class="load-subtitle">AI Sketch Converter</div>
    <div class="load-progress">
        <div class="load-row">
            <div class="load-row-label"><span>Neural Network</span><span id="unet-pct">0%</span></div>
            <div class="load-track"><div class="load-fill" id="unet-bar"></div></div>
        </div>
        <div class="load-row">
            <div class="load-row-label"><span>Text Encoder</span><span id="text-pct">0%</span></div>
            <div class="load-track"><div class="load-fill" id="text-bar"></div></div>
        </div>
    </div>
    <div class="load-status" id="load-note">553 MB download on first visit</div>
    <div class="load-error" id="load-error"></div>
</div>

<!-- App -->
<div id="app">
    <div class="navbar">
        <span class="navbar-title">Canvas to Reality</span>
        <span class="navbar-status" id="status"></span>
    </div>

    <div class="canvas-area">
        <div class="pane">
            <div class="pane-header">Sketch</div>
            <div class="pane-body">
                <canvas id="sketch" width="512" height="512"></canvas>
            </div>
        </div>
        <div class="pane">
            <div class="pane-header">Generated</div>
            <div class="pane-body" style="position:relative">
                <canvas id="output" width="512" height="512"></canvas>
                <div class="gen-indicator" id="gen-bar">Generating...</div>
            </div>
        </div>
    </div>

    <div class="bottom-bar">
        <div class="toolbar">
            <!-- Tool select -->
            <div class="seg-control" id="tool-seg">
                <button class="seg-btn active" data-tool="pen">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>
                </button>
                <button class="seg-btn" data-tool="eraser">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 20H7L3 16l8-8 8 8-3 4z"/><path d="M6.5 13.5l5-5"/></svg>
                </button>
            </div>

            <div class="tool-sep"></div>

            <!-- Brush size -->
            <div class="slider-group">
                <span class="slider-label">Size</span>
                <input type="range" id="brush-size" min="1" max="50" value="5">
            </div>

            <div class="tool-sep"></div>

            <!-- Strength -->
            <div class="slider-group">
                <span class="slider-label">Style</span>
                <input type="range" id="strength" min="20" max="100" value="70">
            </div>

            <div class="spacer"></div>

            <!-- Actions -->
            <button class="icon-btn" id="btn-undo" title="Undo (Ctrl+Z)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
            </button>
            <button class="icon-btn" id="btn-clear" title="Clear canvas">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14H6L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4h6v2"/></svg>
            </button>
            <button class="icon-btn" id="btn-reroll" title="New random seed">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="8" height="8" rx="1"/><rect x="14" y="2" width="8" height="8" rx="1"/><rect x="2" y="14" width="8" height="8" rx="1"/><circle cx="18" cy="18" r="4"/></svg>
            </button>
            <button class="icon-btn accent" id="btn-save" title="Save image">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
            </button>

            <div class="tool-sep"></div>

            <button class="mode-pill gpu" id="btn-mode" title="Switch GPU/CPU">GPU</button>
        </div>

        <div class="prompt-row">
            <input type="text" id="prompt"
                   placeholder="Describe your drawing... (e.g. a cat sitting on a hill)"
                   value="watercolor painting of a landscape with mountains and trees">
        </div>
    </div>
</div>

<div id="brush-preview"></div>

<!-- COI for WASM multi-threading -->
<script>
if (!crossOriginIsolated && window.isSecureContext && 'serviceWorker' in navigator) {
    if (!sessionStorage.getItem('coi')) {
        sessionStorage.setItem('coi', '1');
        navigator.serviceWorker.register('coi-sw.js').then(() => {
            window.location.reload();
        });
    }
}
</script>

<!-- ONNX Runtime -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.20.1/dist/ort.all.min.js"></script>

<script type="module">
import { AutoTokenizer } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.1.2';

// ============================================================
//  CONFIG
// ============================================================
const MODEL_BASE = 'https://raw.githubusercontent.com/lsb/sdxs-controlnet-sketch/trunk';
const MODELS = {
    unet:    { url: `${MODEL_BASE}/sd512q68.onnx`,           size: 428957688 },
    textEnc: { url: `${MODEL_BASE}/sd_text_encoder_q8.onnx`, size: 123815043 },
};
const SPLIT = 50_000_000;
const PARALLEL = 4;

// ============================================================
//  UTILS
// ============================================================
const sleep = ms => new Promise(r => setTimeout(r, ms));

async function fetchChunk(url, retries = 3) {
    for (let attempt = 0; attempt < retries; attempt++) {
        try {
            const res = await fetch(url, { mode: 'cors' });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            return new Uint8Array(await res.arrayBuffer());
        } catch (e) {
            if (attempt === retries - 1) throw new Error(`Failed: ${url} (${e.message})`);
            await sleep(1000 * (attempt + 1));
        }
    }
}

async function fetchSplit(url, total, split, onProg) {
    const buf = new Uint8Array(total);
    const n = Math.ceil(total / split);
    let done = 0;
    const t0 = performance.now();
    for (let i = 0; i < n; i += PARALLEL) {
        const batch = [];
        for (let j = i; j < Math.min(i + PARALLEL, n); j++) {
            batch.push(
                fetchChunk(`${url}.${String(j).padStart(3,'0')}.db`).then(chunk => {
                    buf.set(chunk, j * split);
                    done++;
                    const speed = (done * split) / ((performance.now() - t0) / 1000) / 1048576;
                    onProg?.(done / n, speed);
                })
            );
        }
        await Promise.all(batch);
    }
    return buf;
}

// ============================================================
//  ONNX
// ============================================================
const threads = crossOriginIsolated ? (navigator.hardwareConcurrency || 4) : 1;
ort.env.wasm.numThreads = threads;
console.log(`WASM threads: ${threads}, crossOriginIsolated: ${crossOriginIsolated}`);

const gpuOpts = { executionProviders: ['webgpu','wasm'], intraOpNumThreads: threads, interOpNumThreads: threads };
const cpuOpts = { executionProviders: ['wasm'],           intraOpNumThreads: threads, interOpNumThreads: threads };

let unetSession = null, textSession = null, tokenizer = null;
let unetBuf = null, usingWebGPU = false;

const warmupInputs = {
    image:              new ort.Tensor('uint8',   new Uint8Array(512*512).fill(255), [512,512]),
    prompt_embeds:      new ort.Tensor('float32', new Float32Array(1*77*768),        [1,77,768]),
    conditioning_scale: new ort.Tensor('float32', [0.5], [1]),
    latents:            new ort.Tensor('float32', new Float32Array(1*4*64*64).fill(0.1), [1,4,64,64]),
};

async function loadModels() {
    const noteEl = document.getElementById('load-note');

    unetBuf = await fetchSplit(MODELS.unet.url, MODELS.unet.size, SPLIT, (p, speed) => {
        document.getElementById('unet-bar').style.width = (p*100)+'%';
        document.getElementById('unet-pct').textContent  = Math.round(p*100)+'%';
        noteEl.textContent = `${speed.toFixed(1)} MB/s`;
    });

    if (navigator.gpu) {
        try {
            noteEl.textContent = 'Initializing WebGPU...';
            unetSession = await ort.InferenceSession.create(unetBuf, gpuOpts);
            noteEl.textContent = 'Warming up...';
            await unetSession.run(warmupInputs);
            usingWebGPU = true;
            console.log('WebGPU session OK');
        } catch (e) {
            console.warn('WebGPU failed:', e.message);
            unetSession = null;
        }
    }
    if (!unetSession) {
        noteEl.textContent = `Initializing CPU (${threads} threads)...`;
        unetSession = await ort.InferenceSession.create(unetBuf, cpuOpts);
    }

    const textBuf = await fetchSplit(MODELS.textEnc.url, MODELS.textEnc.size, SPLIT, (p, speed) => {
        document.getElementById('text-bar').style.width = (p*100)+'%';
        document.getElementById('text-pct').textContent  = Math.round(p*100)+'%';
        noteEl.textContent = `${speed.toFixed(1)} MB/s`;
    });
    noteEl.textContent = 'Initializing text encoder...';
    textSession = await ort.InferenceSession.create(textBuf, cpuOpts);

    noteEl.textContent = 'Loading tokenizer...';
    tokenizer = await AutoTokenizer.from_pretrained('Xenova/clip-vit-large-patch14');
}

async function switchMode(mode) {
    if (!unetBuf) return;
    const wantGPU = mode === 'gpu';
    if (wantGPU === usingWebGPU) return;
    statusEl.textContent = 'Switching...';
    try {
        unetSession = await ort.InferenceSession.create(unetBuf, wantGPU ? gpuOpts : cpuOpts);
        usingWebGPU = wantGPU;
    } catch {
        unetSession = await ort.InferenceSession.create(unetBuf, cpuOpts);
        usingWebGPU = false;
    }
    updateModeUI();
    sketchDirty = true;
}

function updateModeUI() {
    const btn = document.getElementById('btn-mode');
    btn.textContent = usingWebGPU ? 'GPU' : 'CPU';
    btn.className = `mode-pill ${usingWebGPU ? 'gpu' : 'cpu'}`;
}

async function fallbackToWasm() {
    unetSession = await ort.InferenceSession.create(unetBuf, cpuOpts);
    usingWebGPU = false;
    updateModeUI();
}

// ============================================================
//  DRAWING
// ============================================================
const sketchEl = document.getElementById('sketch');
const sketchCtx = sketchEl.getContext('2d', { willReadFrequently: true });
const outputEl = document.getElementById('output');
const outputCtx = outputEl.getContext('2d');
const statusEl = document.getElementById('status');
const genBar = document.getElementById('gen-bar');

sketchCtx.fillStyle = '#fff';
sketchCtx.fillRect(0, 0, 512, 512);

// Placeholder
outputCtx.fillStyle = '#f2f2f7';
outputCtx.fillRect(0, 0, 512, 512);
outputCtx.fillStyle = '#aeaeb2';
outputCtx.font = '500 15px -apple-system, system-ui, sans-serif';
outputCtx.textAlign = 'center';
outputCtx.fillText('Draw something to generate', 256, 260);

let currentTool = 'pen';
let drawing = false;
let lastX = 0, lastY = 0;
let history = [];
let sketchDirty = true;

function canvasCoords(e) {
    const r = sketchEl.getBoundingClientRect();
    const cx = e.clientX ?? e.touches?.[0]?.clientX ?? 0;
    const cy = e.clientY ?? e.touches?.[0]?.clientY ?? 0;
    return { x: (cx - r.left) * 512 / r.width, y: (cy - r.top) * 512 / r.height };
}

function pointerDown(e) {
    e.preventDefault(); drawing = true;
    const p = canvasCoords(e);
    lastX = p.x; lastY = p.y;
    history.push(sketchCtx.getImageData(0, 0, 512, 512));
    if (history.length > 30) history.shift();
}

function pointerMove(e) {
    e.preventDefault();
    updateBrushPreview(e);
    if (!drawing) return;
    const p = canvasCoords(e);
    const size = +document.getElementById('brush-size').value;
    sketchCtx.beginPath();
    sketchCtx.moveTo(lastX, lastY);
    sketchCtx.lineTo(p.x, p.y);
    sketchCtx.strokeStyle = currentTool === 'pen' ? '#000' : '#fff';
    sketchCtx.lineWidth = size;
    sketchCtx.lineCap = 'round';
    sketchCtx.lineJoin = 'round';
    sketchCtx.stroke();
    lastX = p.x; lastY = p.y;
    sketchDirty = true;
}

function pointerUp(e) { if(e) e.preventDefault(); drawing = false; }

sketchEl.addEventListener('pointerdown', pointerDown);
sketchEl.addEventListener('pointermove', pointerMove);
sketchEl.addEventListener('pointerup', pointerUp);
sketchEl.addEventListener('pointerleave', pointerUp);
sketchEl.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
sketchEl.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

const brushPreview = document.getElementById('brush-preview');
function updateBrushPreview(e) {
    const r = sketchEl.getBoundingClientRect();
    const cx = e.clientX ?? 0, cy = e.clientY ?? 0;
    if (cx < r.left || cx > r.right || cy < r.top || cy > r.bottom) {
        brushPreview.style.display = 'none'; return;
    }
    const sz = +document.getElementById('brush-size').value * (r.width / 512);
    brushPreview.style.display = 'block';
    brushPreview.style.width = sz + 'px';
    brushPreview.style.height = sz + 'px';
    brushPreview.style.left = (cx - sz/2) + 'px';
    brushPreview.style.top = (cy - sz/2) + 'px';
}
sketchEl.addEventListener('pointerleave', () => { brushPreview.style.display = 'none'; });

// ============================================================
//  TOOLBAR
// ============================================================
document.querySelectorAll('[data-tool]').forEach(btn => {
    btn.addEventListener('click', () => {
        currentTool = btn.dataset.tool;
        document.querySelectorAll('[data-tool]').forEach(b => b.classList.toggle('active', b === btn));
        sketchEl.style.cursor = currentTool === 'pen' ? 'crosshair' : 'cell';
    });
});

document.getElementById('btn-undo').addEventListener('click', () => {
    if (history.length) { sketchCtx.putImageData(history.pop(), 0, 0); sketchDirty = true; }
});
document.getElementById('btn-clear').addEventListener('click', () => {
    history.push(sketchCtx.getImageData(0, 0, 512, 512));
    sketchCtx.fillStyle = '#fff';
    sketchCtx.fillRect(0, 0, 512, 512);
    sketchDirty = true;
});
document.getElementById('btn-reroll').addEventListener('click', () => {
    state.latents = makeLatents(); sketchDirty = true;
});
document.getElementById('btn-mode').addEventListener('click', () => {
    switchMode(usingWebGPU ? 'cpu' : 'gpu');
});
document.getElementById('btn-save').addEventListener('click', () => {
    const a = document.createElement('a');
    a.download = `canr-${Date.now()}.png`;
    a.href = outputEl.toDataURL('image/png');
    a.click();
});
document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT') return;
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        document.getElementById('btn-undo').click();
    }
});

// ============================================================
//  INFERENCE
// ============================================================
function makeLatents() {
    return new ort.Tensor('float32', Float32Array.from(
        { length: 1*4*64*64 },
        () => Math.sqrt(-2 * Math.log(Math.random())) * Math.cos(2 * Math.PI * Math.random())
    ), [1, 4, 64, 64]);
}

const state = {
    promptEmbeds: new ort.Tensor('float32', new Float32Array(1*77*768), [1,77,768]),
    promptDirty: true,
    latents: makeLatents(),
    blackCount: 0,
};

function getSketchTensor() {
    const px = sketchCtx.getImageData(0, 0, 512, 512).data;
    const g = new Uint8Array(262144);
    for (let i = 0; i < 262144; i++) g[i] = px[i << 2];
    return new ort.Tensor('uint8', g, [512, 512]);
}

async function encodePrompt(text) {
    const tok = tokenizer([text], { padding: true, truncation: true, max_length: tokenizer.model_max_length });
    return (await textSession.run({
        input_ids: new ort.Tensor('int64', tok.input_ids.data, [1, tokenizer.model_max_length])
    })).output_embeddings;
}

const scaleTensor = new ort.Tensor('float32', new Float32Array(1), [1]);
const outputImgData = new ImageData(512, 512);

async function runInference() {
    scaleTensor.data[0] = +document.getElementById('strength').value / 100;
    const result = await unetSession.run({
        image: getSketchTensor(),
        prompt_embeds: state.promptEmbeds,
        conditioning_scale: scaleTensor,
        latents: state.latents,
    });
    const d = result.output_image.data;

    // Black output detection
    let sum = 0;
    for (let i = 0; i < 7500; i++) sum += d[i];
    if (sum === 0) {
        if (++state.blackCount > 5) { state.blackCount = 0; await fallbackToWasm(); return; }
    } else { state.blackCount = 0; }

    const rgba = outputImgData.data;
    for (let i = 0; i < 262144; i++) {
        const i3 = i * 3, i4 = i << 2;
        rgba[i4] = d[i3]; rgba[i4+1] = d[i3+1]; rgba[i4+2] = d[i3+2]; rgba[i4+3] = 255;
    }
    outputCtx.putImageData(outputImgData, 0, 0);
}

// ============================================================
//  PROMPT
// ============================================================
const promptEl = document.getElementById('prompt');
let lastEncodedPrompt = '';
let promptTimer = null;
promptEl.addEventListener('input', () => {
    clearTimeout(promptTimer);
    promptTimer = setTimeout(() => { state.promptDirty = true; }, 500);
});

async function refreshPrompt() {
    if (!state.promptDirty || !textSession) return;
    const text = promptEl.value.trim() || 'a drawing';
    if (text === lastEncodedPrompt) { state.promptDirty = false; return; }
    state.promptDirty = false;
    state.promptEmbeds = await encodePrompt(text);
    lastEncodedPrompt = text;
    sketchDirty = true;
}

// ============================================================
//  MAIN LOOP
// ============================================================
let busy = false;

async function loop() {
    if (!unetSession) { setTimeout(loop, 200); return; }
    await refreshPrompt();

    if (sketchDirty && !busy) {
        busy = true; sketchDirty = false;
        genBar.classList.add('active');
        const t0 = performance.now();
        try {
            await runInference();
            const ms = Math.round(performance.now() - t0);
            statusEl.textContent = `${ms}ms`;
        } catch (err) {
            console.error('Inference error:', err);
            if (usingWebGPU) { await fallbackToWasm(); sketchDirty = true; }
            else { statusEl.textContent = 'Error'; }
        }
        genBar.classList.remove('active');
        busy = false;
    }
    setTimeout(() => requestAnimationFrame(loop), 60);
}

// ============================================================
//  INIT
// ============================================================
async function init() {
    try {
        await loadModels();
        document.getElementById('loading-screen').classList.add('done');
        document.getElementById('app').classList.add('active');
        updateModeUI();
        statusEl.textContent = 'Ready';
        state.promptDirty = true;
        loop();
    } catch (err) {
        console.error('Init error:', err);
        const el = document.getElementById('load-error');
        el.style.display = 'block';
        el.textContent = err.message;
    }
}

init();
</script>
</body>
</html>
